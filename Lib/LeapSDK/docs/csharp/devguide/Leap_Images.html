


  
  
 
  
  
 


<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Camera Images &mdash; Leap Motion C# and Unity SDK v2.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.0.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.0.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.0.0/css/font-awesome.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.9.1.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.0.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.0.0/css/font-awesome.min.css"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Leap Motion C# and Unity SDK v2.1 documentation" href="../index.html" />
    <link rel="up" title="Using the Tracking API" href="Leap_Guides2.html" />
    <link rel="next" title="API Reference" href="../api/Leap_Classes.html" />
    <link rel="prev" title="Coordinate Systems" href="Leap_Coordinate_Mapping.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31536531-1']);
  _gaq.push(['_setDomainName', 'leapmotion.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


<script type="text/javascript" src="../_static/leap.min.js"></script>
<script type="text/javascript" src="../_static/three.min.js"></script>
<script type="text/javascript" src="../_static/LeapExample.js"></script>
<script type="text/javascript" src="../_static/kinetic.min.js"></script>
<script type="text/javascript" src="../_static/dat.gui.min.js"></script>

 

<script>

    function getQueryValue(variable)
    {
        var query = window.location.search.substring(1);
        var vars = query.split("&");
        for (var i=0;i<vars.length;i++) {
            var pair = vars[i].split("=");
            if(pair[0] == variable){return pair[1];}
        }
        return(false);
    }

    var requestedAPI = getQueryValue("proglang");
    if(requestedAPI == "current") requestedAPI = localStorage["currentAPI"];
    var pageAPI = 'csharp';
    var hasAPI = {};
    hasAPI.cpp = true;
    hasAPI.csharp = true;
    hasAPI.objc = true;
    hasAPI.java = true;
    hasAPI.javascript = true;
    hasAPI.python = true;

    if(requestedAPI && (requestedAPI != pageAPI))
    {
        if(pageAPI != 'none'){
            var redirectedLocation = '../../csharp/devguide/Leap_Images.html';
            if( requestedAPI == 'cpp' && hasAPI.cpp){
                redirectedLocation = "../../cpp/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'csharp' && hasAPI.csharp){
                redirectedLocation = "../../csharp/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'objc' && hasAPI.objc){
                redirectedLocation = "../../objc/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'java' && hasAPI.java) {
                redirectedLocation = "../../java/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'javascript' && hasAPI.javascript){
                redirectedLocation = "../../javascript/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'python' && hasAPI.python) {
                redirectedLocation = "../../python/devguide/Leap_Images.html";
            } else {
                    redirectedLocation ="Leap_Guides2.html";
            }

            //Guard against redirecting to the same page (infinitely)
            if('../../csharp/devguide/Leap_Images.html' != redirectedLocation) window.location.replace(redirectedLocation);
        }
    }

</script>

<script>
window.addEventListener('keyup', handleKeyInput);
function handleKeyInput(e)
{
    var code;
    if (!e) var e = window.event;
    if (e.keyCode) code = e.keyCode;
    else if (e.which) code = e.which;
    var character = String.fromCharCode(code);
    if( character == "J" & e.altKey){
            window.location.assign("Leap_Coordinate_Mapping.html");    }
    else if( character == "K" & e.altKey){
            window.location.assign("../api/Leap_Classes.html");
    }

}
</script>
<script type="text/javascript" src="../_static/leap.min.js"></script>
<script type="text/javascript" src="../_static/three.min.js"></script>
<script type="text/javascript" src="../_static/LeapExample.js"></script>

<script type="text/javascript" src="/assets/standalone-header.js?r9"></script>
<link rel="stylesheet" href="/assets/standalone-header.css?r9" type="text/css" />


  </head>
  <body>

<div class="developer-portal-styles">
  <header class="navbar navbar-static-top developer-navbar header beta-header">
    <nav class="container pr">
      <a class="logo-link pull-left" href="/">
        <img alt="Leap Motion Developers" class="media-object pull-left white-background" src="../_static/logo.png" />
      </a>
      <span class="inline-block hidden-phone developer-logo-text">
        <div class="text">
          <a href="/">
            <span class="more-than-1199">Developer Portal</span>

          </a>
        </div>
      </span>

      <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <!-- Everything within here will be hidden at 940px or less, accessible via a button. -->
      <div class="nav-collapse">
        <ul class="nav header-navigation developer-links">
          <li class="external-link"><a href="https://developer.leapmotion.com/features">What's new</a> </li>
          <li class="external-link"><a href="https://developer.leapmotion.com/downloads/skeletal-beta" class="">Getting Started</a></li>
          <li><a class="active" href="#" class="">Documentation</a></li>
          <li class="external-link"> <a href="https://developer.leapmotion.com/gallery" class="">Examples</a> </li>
          <li class="external-link"> <a href="https://www.leapmotion.com/blog/category/labs/" class="" target="_blank">Blog <i class='fa fa-external-link'></i></a> </li>
          <li class="external-link"> <a href="https://community.leapmotion.com/category/beta" class="" target="_blank">Community <i class='fa fa-external-link'></i></a> </li>
        </ul>
      </div>

    </nav>
  </header>
</div>
<section class="main-wrap">
  <div data-swiftype-index="true">
    <div class="second_navigation">
      <div class="container">
        <div class="row">
          <div class="col-md-8">
            
              

<ul>
  <li>
      <a href="../../javascript/devguide/Leap_Images.html" onclick="localStorage['currentAPI'] = 'javascript'">JavaScript</a>
    
  </li>
  <li>
      C# and Unity
    
  </li>
  <li>
      <a href="../../cpp/devguide/Leap_Images.html" onclick="localStorage['currentAPI'] = 'cpp'">C++</a>
    
  </li>
  <li>
      <a href="../../java/devguide/Leap_Images.html" onclick="localStorage['currentAPI'] = 'java'">Java</a>
    
  </li>
  <li>
      <a href="../../python/devguide/Leap_Images.html" onclick="localStorage['currentAPI'] = 'python'">Python</a>
    
  </li>
  <li>
      <a href="../../objc/devguide/Leap_Images.html" onclick="localStorage['currentAPI'] = 'objc'">Objective-C</a>
    
  </li>
</ul>
            
          </div>
          <div class="col-md-4 search">
            
              <script>
function storeThisPage(){
    sessionStorage["pageBeforeSearch"] = window.location;
    return true;
}
function doneWithSearch(){
    var storedPage = sessionStorage["pageBeforeSearch"];
    if(storedPage){
        window.location = storedPage;
    } else {
        window.location = "index.html"; //fallback
    }
    return false;
}
</script>
<div  style="margin-top:-4px">
<ul style="display:inline; white-space:nowrap"><li>
<form class="navbar-form" action="../search.html" method="get" onsubmit="storeThisPage()">
 <div class="form-group">
  <input type="search" results="5" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form></li>
</ul>
</div>
            
          </div>
        </div>
      </div>
    </div>
    <script>
        //Remove dev portal header and footer when viewing from file system
       if(window.location.protocol == 'file:'){
            var navNode = document.querySelector(".developer-links");
            navNode.parentNode.removeChild(navNode);
        }

    </script>


<div id="wrap" data-spy="scroll" data-target="#sidebar">
  <div class="container">
    <div class="row">
      <div class="col-md-9 pull-right">
        <!-- 
 
<span id="breadcrumbs">
  <a href="../index.html">Home</a>&raquo;
    <a href="Leap_Guides2.html" accesskey="U">Using the Tracking API</a>&raquo;
  Camera Images
</span> -->
        
  <div class="section" id="camera-images">
<h1>Camera Images<a class="headerlink" href="#camera-images" title="Permalink to this headline">¶</a></h1>
<p>The Leap Motion controller uses infrared stereo cameras as tracking sensors. You can access the images from these cameras using the <a class="reference external" href="../api/Leap.Frame.html#csharpclass_leap_1_1_frame_1aa98ec4aa16d4d39e5e0b3cc46e6cd4d5">Frame.Images</a> function. This function provides an <a class="reference external" href="../api/Leap.ImageList.html"><tt class="docutils literal"><span class="pre">ImageList</span></tt></a> object, which contains the <a class="reference external" href="../api/Leap.Image.html"><tt class="docutils literal"><span class="pre">Image</span></tt></a> objects for the frame.</p>
<div class="figure align-center">
<img alt="devguide/../../../images/Leap_Image_Raw.png" src="devguide/../../../images/Leap_Image_Raw.png" />
<p class="caption">An image from one of the cameras. The calibration grid is superimposed on the image highlighting the significant, complex distortion.</p>
</div>
<p>The images can be used for:</p>
<ul class="simple">
<li>Head-mounted display video pass-through</li>
<li>Augmented reality</li>
<li>Computer vision</li>
</ul>
<p>The Image API provides a buffer containing the sensor brightness values and a buffer containing the camera calibration map, which can be used to correct lens distortion and other optical imperfections in the image data.</p>
<div class="section" id="image-api-basics">
<h2>Image API Basics<a class="headerlink" href="#image-api-basics" title="Permalink to this headline">¶</a></h2>
<p>When a ray of light enters one of the Leap Motion cameras, the lens bends the light ray so that it hits the sensor, which records it as a greyscale brightness value at a specific pixel location. Of course, no lens is perfect, so a ray of light does not land on the sensor in the optically perfect spot. The calibration map provides data to correct this imperfection, allowing you to calculate the true angle of the original ray of light. You can use the corrected angle to generate a distortion-free image, and, using the angles from both images in the stereo pair, you can triangulate the 3D location of a feature identified in both images.</p>
<p>For image correction, the distortion data can be fed to a shader program that can efficiently interpolate the correction applied to rays of light. For getting the true angle for a small set of points, you can use the <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a53f35cbf0590d9b7a3c11e989ad95905">Image.Warp()</a> function (but this is not efficient enough to transform a full bitmap at a high frame rate).</p>
<p>The distortion data is based on the angle of view of the Leap Motion cameras. The image class provides functions, <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1ab4d4669fed8c0e7a10e151ab7b082a9c">Image.RayScaleX</a> and <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a7affe047d269bb41f9cf6a3896363079">Image.RayScaleY</a> that are proportional to view angles large enough to ensure that distortion map covers the entire view, about 150 degrees for the current Leap Motion peripheral. A 150 degree angle of view means that a light ray passing through the lens has a maximum slope of 4/1.</p>
<div class="figure align-center">
<img alt="devguide/../../../images/Leap_Image_Rays.png" src="devguide/../../../images/Leap_Image_Rays.png" />
<p class="caption">A view angle of 150 degrees corresponds to a slope of (+-) 4 (the tangent of 75 degrees is approximately 4)</p>
</div>
<p>The image above shows a reconstruction of the distortion-corrected image data. The brightness value of each pixel in the image originated from a ray of light entering the camera from a specific direction. The image is reconstructed by calculating the horizontal and vertical slopes represented by each pixel and finding the true brightness value from the image data using the calibration map. The red portions of the image represent areas within the rendering for which no brightness value is available (the actual field of view is less than 150 degrees).</p>
</div>
<div class="section" id="get-the-raw-images">
<h2>Get the Raw Images<a class="headerlink" href="#get-the-raw-images" title="Permalink to this headline">¶</a></h2>
<p>Before you can get image data, you must set the POLICY_IMAGES flag using the <a class="reference external" href="../api/Leap.Controller.html#csharpclass_leap_1_1_controller_1a5ca7e1090e78eb89e0d8d9419ea580f9">Controller.SetPolicyFlags()</a> function. For privacy reasons, each user must also enable the feature in the Leap Motion control panel for any application to get the raw camera images.</p>
<div class="highlight-csharp"><div class="highlight"><pre><span class="k">this</span><span class="p">.</span><span class="n">controller</span><span class="p">.</span><span class="n">SetPolicyFlags</span><span class="p">(</span><span class="n">Controller</span><span class="p">.</span><span class="n">PolicyFlag</span><span class="p">.</span><span class="n">POLICY_IMAGES</span><span class="p">);</span>
</pre></div>
</div>
<p>To get the image data, use the <a class="reference external" href="../api/Leap.Frame.html#csharpclass_leap_1_1_frame_1aa98ec4aa16d4d39e5e0b3cc46e6cd4d5">Frame.Images</a> function. This provides a list of images. Since the Leap Motion peripheral has two cameras, the image list for a frame contains two images (this could change in the future if multiple Leap Motion devices can be active at the same time). The image at index 0 is the left camera; the image at index 1 is the right camera. Note that the left-right orientation of the peripheral can be detected automatically based on the direction from which the user inserts his or her hand into the field of view. Detection is enabled by the auto-orientation setting in the Leap Motion control panel.</p>
<p>Once you have an <a class="reference external" href="../api/Leap.Image.html"><tt class="docutils literal"><span class="pre">Image</span></tt></a> object, you can get the 8-bit brightness values from the <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a499ef9f0f52fe3cee348b490ddb815ca">Data</a> buffer. The length of this buffer is <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1abbe7749c3b402f7dfe64f936774cfcd4">Image.Width</a> times <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1aaadefba794062a2ca7e58ceb10b955a1">Image.Height</a>. The width and height of the image changes with the current operating mode of the controller, which can change from frame to frame.</p>
<p>The following example gets the image list from a frame and copies the brightness values from the Data buffer to a bitmap:</p>
<div class="highlight-csharp"><div class="highlight"><pre><span class="n">Leap</span><span class="p">.</span><span class="n">Image</span> <span class="n">image</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Images</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
<span class="n">Bitmap</span> <span class="n">bitmap</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bitmap</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">Width</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">Height</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Drawing</span><span class="p">.</span><span class="n">Imaging</span><span class="p">.</span><span class="n">PixelFormat</span><span class="p">.</span><span class="n">Format8bppIndexed</span><span class="p">);</span>
<span class="c1">//set palette</span>
<span class="n">ColorPalette</span> <span class="n">grayscale</span> <span class="p">=</span> <span class="n">bitmap</span><span class="p">.</span><span class="n">Palette</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">256</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">grayscale</span><span class="p">.</span><span class="n">Entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">FromArgb</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="m">255</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">bitmap</span><span class="p">.</span><span class="n">Palette</span> <span class="p">=</span> <span class="n">grayscale</span><span class="p">;</span>
<span class="n">Rectangle</span> <span class="n">lockArea</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Rectangle</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">.</span><span class="n">Width</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">.</span><span class="n">Height</span><span class="p">);</span>
<span class="n">BitmapData</span> <span class="n">bitmapData</span> <span class="p">=</span> <span class="n">bitmap</span><span class="p">.</span><span class="n">LockBits</span><span class="p">(</span><span class="n">lockArea</span><span class="p">,</span> <span class="n">ImageLockMode</span><span class="p">.</span><span class="n">WriteOnly</span><span class="p">,</span> <span class="n">PixelFormat</span><span class="p">.</span><span class="n">Format8bppIndexed</span><span class="p">);</span>
<span class="kt">byte</span><span class="p">[]</span> <span class="n">rawImageData</span> <span class="p">=</span> <span class="n">image</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="n">Runtime</span><span class="p">.</span><span class="n">InteropServices</span><span class="p">.</span><span class="n">Marshal</span><span class="p">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">rawImageData</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">bitmapData</span><span class="p">.</span><span class="n">Scan0</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">Width</span> <span class="p">*</span> <span class="n">image</span><span class="p">.</span><span class="n">Height</span><span class="p">);</span>
<span class="n">bitmap</span><span class="p">.</span><span class="n">UnlockBits</span><span class="p">(</span><span class="n">bitmapData</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="get-the-calibration-map">
<h2>Get the Calibration Map<a class="headerlink" href="#get-the-calibration-map" title="Permalink to this headline">¶</a></h2>
<p>The calibration map can be used to correct image distortion due to lens curvature and other imperfections. The map is a 64x64 grid of points. Each point consists of two 32-bit values, so the buffer size is 128 times 64 times 4. You can get the calibration map buffer using the <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1ad97445b1c3e8783c9b6ac1b87f57f1db">Image.Distortion</a> function.</p>
<p>Each point in the buffer indicates where to find the corrected brightness value for the corresponding pixel in the raw image. Valid coordinates are normalized in the range [0..1]. Individual elements of the calibration map can have a value in the range [-0.6..2.3], but coordinates below zero or above 1 are invalid. Discard values outside the range [0..1] when using the calibration data.</p>
<p>To convert to pixel coordinates multiply by the width or height of the image. For pixels that lie in between the calibration grid points, you can interpolate between the nearest grid points. The camera lenses have a very large angle of view (roughly 150 degrees) and have a large amount of distortion. Because of this, not every point in the calibration grid maps to a valid pixel. The following rendering shows the lens correction data as color values. The left image shows the x values; the right side shows the y values.</p>
<div class="figure align-center">
<img alt="devguide/../../../images/Leap_Distortion.png" src="devguide/../../../images/Leap_Distortion.png" />
<p class="caption">The red values indicate map values that fall outside the image.</p>
</div>
<p>The size of the calibration map is subject to change in the future, so the <tt class="docutils literal"><span class="pre">Image</span></tt> class provides the grid dimensions with the <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1afa96b3c56a4b896e80cd1ced1b6e546e">DistortionWidth</a> (actually twice the width to account for two values per grid point) and <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a8cf61186cd21e4f74be05729d5becb66">DistortionHeight</a> functions. The length of the buffer containing the calibration data is <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1afa96b3c56a4b896e80cd1ced1b6e546e">DistortionWidth</a> times <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a8cf61186cd21e4f74be05729d5becb66">DistortionHeight</a>.</p>
<blockquote>
<div><p>The following example illustrates how to get the calibration data:</p>
<div class="highlight-csharp"><div class="highlight"><pre><span class="kt">float</span><span class="p">[]</span> <span class="n">distortionBuffer</span> <span class="p">=</span> <span class="n">image</span><span class="p">.</span><span class="n">Distortion</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">d</span> <span class="p">&lt;</span> <span class="n">image</span><span class="p">.</span><span class="n">DistortionWidth</span> <span class="p">*</span> <span class="n">image</span><span class="p">.</span><span class="n">DistortionHeight</span><span class="p">;</span> <span class="n">d</span> <span class="p">+=</span> <span class="m">2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">dX</span> <span class="p">=</span> <span class="n">distortionBuffer</span><span class="p">[</span><span class="n">d</span><span class="p">];</span>
    <span class="kt">float</span> <span class="n">dY</span> <span class="p">=</span> <span class="n">distortionBuffer</span><span class="p">[</span><span class="n">d</span> <span class="p">+</span> <span class="m">1</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(!((</span><span class="n">dX</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">dX</span> <span class="p">&gt;</span> <span class="m">1</span><span class="p">))</span> <span class="p">&amp;&amp;</span> <span class="p">!((</span><span class="n">dY</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">dY</span> <span class="p">&gt;</span> <span class="m">1</span><span class="p">)))</span>
    <span class="p">{</span>
        <span class="c1">//Use valid distortion point</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Note that the calibration map seldom changes. It can change if you change devices, if you change the <tt class="docutils literal"><span class="pre">head_mounted_display_mode</span></tt> setting, or if you recalibrate the device. In performance-critical applications, you can save a few CPU cycles by only updating distortion image textures occasionally.</p>
</div>
<div class="section" id="image-ray-correction">
<h2>Image Ray Correction<a class="headerlink" href="#image-ray-correction" title="Permalink to this headline">¶</a></h2>
<p>You can correct the raw image distortion in two ways:</p>
<ul class="simple">
<li>Use the <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a53f35cbf0590d9b7a3c11e989ad95905">Image.Warp()</a> and <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a7b31c05de1ce426d87dda5f0188fa675">Image.Rectify()</a> functions.</li>
<li>Use the data in the <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1ad97445b1c3e8783c9b6ac1b87f57f1db">Image.Distortion</a> buffer directly.</li>
</ul>
<p>The <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a53f35cbf0590d9b7a3c11e989ad95905">Warp()</a> and <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a7b31c05de1ce426d87dda5f0188fa675">Rectify()</a> functions are the simpler method, but processing each pixel individually on the CPU is relatively slow. Use these functions if you are only correcting a few points, you don&#8217;t need to process data in real time, or when you cannot use GPU shaders. The Distortion buffer is designed to be used with a GPU shader program and can correct the entire raw image while maintaining a good application frame rate.</p>
<div class="section" id="correction-using-image-warp-and-image-rectify">
<h3>Correction using Image.Warp() and Image.Rectify()<a class="headerlink" href="#correction-using-image-warp-and-image-rectify" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a53f35cbf0590d9b7a3c11e989ad95905">Image.Warp()</a> takes a ray direction and returns the pixel coordinates into the raw image data that specify the brightness value recorded for that ray direction. <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a7b31c05de1ce426d87dda5f0188fa675">Image.Rectify()</a> takes the coordinates of a pixel in the raw image data and returns the corrected ray angle.</p>
<p>The following example uses the Warp() function to rasterize the distortion-corrected image.</p>
<p>To create the image, the example creates a target bitmap and then, for each pixel, computes the direction of the ray of light that would strike the pixel through an ideal lens. The Warp() function is then used to look up the correct brightness value.</p>
<div class="highlight-csharp"><div class="highlight"><pre><span class="c1">//Draw the undistorted image using the warp() function</span>
<span class="kt">int</span> <span class="n">targetWidth</span> <span class="p">=</span> <span class="m">400</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">targetHeight</span> <span class="p">=</span> <span class="m">400</span><span class="p">;</span>
<span class="n">Rectangle</span> <span class="n">lockBounds</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Rectangle</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">targetWidth</span><span class="p">,</span> <span class="n">targetHeight</span><span class="p">);</span>
<span class="n">Bitmap</span> <span class="n">targetBitmap</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bitmap</span><span class="p">(</span><span class="n">targetWidth</span><span class="p">,</span> <span class="n">targetHeight</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Drawing</span><span class="p">.</span><span class="n">Imaging</span><span class="p">.</span><span class="n">PixelFormat</span><span class="p">.</span><span class="n">Format24bppRgb</span><span class="p">);</span>

<span class="c1">//Iterate over target image pixels, converting xy to ray slope</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">float</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="n">targetHeight</span><span class="p">;</span> <span class="n">y</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">float</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">targetWidth</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="c1">//Normalize from pixel xy to range [0..1]</span>
        <span class="n">Vector</span> <span class="n">input</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">x</span> <span class="p">/</span> <span class="n">targetWidth</span><span class="p">,</span> <span class="n">y</span> <span class="p">/</span> <span class="n">targetHeight</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
        <span class="c1">//Debug.WriteLine(&quot;Input slope: &quot; + input);</span>

        <span class="c1">//Convert from normalized [0..1] to slope [-4..4]</span>
        <span class="n">input</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">x</span> <span class="p">-</span> <span class="n">image</span><span class="p">.</span><span class="n">RayOffsetX</span><span class="p">)</span> <span class="p">/</span> <span class="n">image</span><span class="p">.</span><span class="n">RayScaleX</span><span class="p">;</span>
        <span class="n">input</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="n">image</span><span class="p">.</span><span class="n">RayOffsetY</span><span class="p">)</span> <span class="p">/</span> <span class="n">image</span><span class="p">.</span><span class="n">RayScaleY</span><span class="p">;</span>

        <span class="c1">//Use slope to get coordinates of point in image.Data containing the brightness for this target pixel</span>
        <span class="n">Vector</span> <span class="n">pixel</span> <span class="p">=</span> <span class="n">image</span><span class="p">.</span><span class="n">Warp</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
        <span class="c1">//Debug.WriteLine(&quot;Input s;ope: &quot; + input + &quot;, output: &quot; + pixel);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pixel</span><span class="p">.</span><span class="n">x</span> <span class="p">&gt;=</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">pixel</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">image</span><span class="p">.</span><span class="n">Width</span> <span class="p">&amp;&amp;</span> <span class="n">pixel</span><span class="p">.</span><span class="n">y</span> <span class="p">&gt;=</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">pixel</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="n">image</span><span class="p">.</span><span class="n">Height</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">dataIndex</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">Math</span><span class="p">.</span><span class="n">Floor</span><span class="p">(</span><span class="n">pixel</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">*</span> <span class="n">image</span><span class="p">.</span><span class="n">Width</span> <span class="p">+</span> <span class="n">Math</span><span class="p">.</span><span class="n">Floor</span><span class="p">(</span><span class="n">pixel</span><span class="p">.</span><span class="n">x</span><span class="p">));</span> <span class="c1">//xy to buffer index</span>
            <span class="c1">//Debug.WriteLine(&quot;DI: &quot; + dataIndex);</span>
            <span class="kt">byte</span> <span class="n">brightness</span> <span class="p">=</span> <span class="n">rawImageData</span><span class="p">[</span><span class="n">dataIndex</span><span class="p">];</span>
            <span class="n">targetBitmap</span><span class="p">.</span><span class="n">SetPixel</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">y</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">FromArgb</span><span class="p">(</span><span class="n">brightness</span><span class="p">,</span> <span class="n">brightness</span><span class="p">,</span> <span class="n">brightness</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">targetBitmap</span><span class="p">.</span><span class="n">SetPixel</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">y</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">);</span> <span class="c1">//Display invalid pixels as red</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The example uses Bitmap.SetPixel to draw each image in the pixel. This is not a particularly efficient way to draw the undistorted image, however, and the frame rate is quite low. For a more efficient approach, use OpenGL and shader programs.</p>
<p>For an example using <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a7b31c05de1ce426d87dda5f0188fa675">Image.Rectify()</a>, see <a class="reference internal" href="#calculate-the-direction-to-an-image-feature">Calculate the Direction to an Image Feature</a></p>
</div>
<div class="section" id="correction-using-shaders">
<h3>Correction using Shaders<a class="headerlink" href="#correction-using-shaders" title="Permalink to this headline">¶</a></h3>
<p>A more efficient way to correct the entire image is to use a GPU shader program. Pass the image data to a fragment shader as a normal texture and the distortion data as encoded textures. You can then texture a quad by decoding the distortion data and using that to look up the correct brightness value in the image texture.</p>
<p>TODO: example code</p>
</div>
<div class="section" id="encoding-distortion-data-in-an-24-bit-argb-texture">
<h3>Encoding Distortion Data in an 24-bit ARGB Texture<a class="headerlink" href="#encoding-distortion-data-in-an-24-bit-argb-texture" title="Permalink to this headline">¶</a></h3>
<p>If a 32-bit-per-component texture format is not available on your target platform, you can use a separate texture for the x and y lookup values and encode the floating point values into multiple color components. You then have to decode the values before using them to look up the raw brightness values.</p>
<p>A common method for encoding floating point data in a texture is to decompose the input value into four lower-precision values and then restore them in the shader. For example, you can encode a floating point number into a Color object that has four 8-bit components as follows:</p>
<div class="code cpp highlight-python"><div class="highlight"><pre>Color encodeFloatRGBA(float input)
{
    input = (input + 0.6)/2.3; //scale the input value to the range [0..1]
    float r = input;
    float g = input * 255;
    float b = input * 255 * 255;
    float a = input * 255 * 255 * 255;

    r = r - (float)Math.floor(r);
    g = g - (float)Math.floor(g);
    b = b - (float)Math.floor(b);
    a = a - (float)Math.floor(a);

    return Color(r, g, b, a);
}
</pre></div>
</div>
<p>To recompose the value in the fragment shader, you look up the value in the texture and perform the reciprocal operation. To avoid losing too much precision, encode the x and y distortion values in separate textures. Once the distortion indices are sampled from the textures and decoded, you can look up the correct brightness value from the camera image texture.</p>
<div class="code c highlight-python"><div class="highlight"><pre>uniform sampler2D texture;
uniform sampler2D vDistortion;
uniform sampler2D hDistortion;

varying vec2 distortionLookup;
varying vec4 vertColor;
varying vec4 vertTexCoord;

const vec4 decoderCoefficients = vec4(1.0, 1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0));

void main() {
  vec4 vEncoded = texture2D(vDistortion, vertTexCoord.st);
  vec4 hEncoded = texture2D(hDistortion, vertTexCoord.st);
  float vIndex = dot(vEncoded, decoderCoefficients) * 2.3 - 0.6;
  float hIndex = dot(hEncoded, decoderCoefficients) * 2.3 - 0.6;

  if(vIndex &gt;= 0.0 &amp;&amp; vIndex &lt;= 1.0
        &amp;&amp; hIndex &gt;= 0.0 &amp;&amp; hIndex &lt;= 1.0)
  {
      gl_FragColor = texture2D(texture, vec2(hIndex, vIndex)) * vertColor;
  } else {
      gl_FragColor = vec4(1.0, 0, 0, 1.0); //show invalid pixels as red
  }
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="draw-tracking-data-over-image">
<h2>Draw Tracking Data over Image<a class="headerlink" href="#draw-tracking-data-over-image" title="Permalink to this headline">¶</a></h2>
<p>It is reasonably straightforward to draw representations of the Leap Motion tracking data over the camera image. If you have drawn the raw image data to a bitmap, you can find the pixel corresponding to a Leap Motion position using the <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a53f35cbf0590d9b7a3c11e989ad95905">Warp()</a> function.</p>
<p>Converting a position in Leap Motion coordinates to horizontal and vertical slopes (from the camera perspective) requires knowing how far the cameras are from the origin of the Leap Motion coordinate system. For the current peripheral version, the offset on the x axis is 20mm to either side. The cameras are on the x-axis, so there is no z offset. The slope is simply the distance from the camera in the image plane &#8211; the x-coordinate for the horizontal slope; the z-coordinate for the vertical slope &#8211; divided by the distance to the image plane, the z-coordinate. The following diagram illustrates the geometry for the horizontal slope:</p>
<div class="figure align-center">
<img alt="devguide/../../../images/Image_Slope.png" src="devguide/../../../images/Image_Slope.png" />
<p class="caption">The calculation is shown for the left camera; add the offset distance instead of subtracting for the right camera.</p>
</div>
<p>Once you know the ray slope values, you can get the pixel coordinates using Warp().</p>
<p>Note: The offset can be different for different form factors of the Leap Motion controller, but there is currently no way to get this value from the API.</p>
<p>The following example draws bright pixels at the finger tips in the image.</p>
<div class="highlight-csharp"><div class="highlight"><pre><span class="kt">float</span> <span class="n">cameraOffset</span> <span class="p">=</span> <span class="m">20</span><span class="p">;</span> <span class="c1">//x-axis offset in millimeters</span>
<span class="n">FingerList</span> <span class="n">fingers</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Fingers</span><span class="p">;</span>
<span class="k">foreach</span> <span class="p">(</span><span class="n">Finger</span> <span class="n">finger</span> <span class="k">in</span> <span class="n">fingers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Vector</span> <span class="n">tip</span> <span class="p">=</span> <span class="n">finger</span><span class="p">.</span><span class="n">TipPosition</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">hSlope</span> <span class="p">=</span> <span class="p">-(</span><span class="n">tip</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> <span class="n">cameraOffset</span> <span class="p">*</span> <span class="p">(</span><span class="m">2</span> <span class="p">*</span> <span class="n">image</span><span class="p">.</span><span class="n">Id</span> <span class="p">-</span> <span class="m">1</span><span class="p">))/</span><span class="n">tip</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">vSlope</span> <span class="p">=</span> <span class="n">tip</span><span class="p">.</span><span class="n">z</span><span class="p">/</span><span class="n">tip</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

    <span class="n">Vector</span> <span class="n">pixel</span> <span class="p">=</span> <span class="n">image</span><span class="p">.</span><span class="n">Warp</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">hSlope</span><span class="p">,</span> <span class="n">vSlope</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
    <span class="c1">//Draw tip at pixel</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you have rendered the corrected image data, then correlating tracking data to the image data depends on how you rendered the image. For 3D scenes, this is a matter of using a consistent scale and correct placement of the textured quad showing the camera image. For other types of rendering, you must convert the ray slopes representing a Leap Motion position to a target image pixel according to the way that you corrected the image data.</p>
<p>The following example displays bright pixels at the finger tip positions on the distortion corrected image rendered in the example above.</p>
<div class="highlight-csharp"><div class="highlight"><pre><span class="kt">float</span> <span class="n">cameraXOffset</span> <span class="p">=</span> <span class="m">20</span><span class="p">;</span> <span class="c1">//millimeters</span>
<span class="n">FingerList</span> <span class="n">fingerList</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Fingers</span><span class="p">;</span>
<span class="k">foreach</span> <span class="p">(</span><span class="n">Finger</span> <span class="n">finger</span> <span class="k">in</span> <span class="n">fingerList</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Vector</span> <span class="n">tip</span> <span class="p">=</span> <span class="n">finger</span><span class="p">.</span><span class="n">TipPosition</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">hSlope</span> <span class="p">=</span> <span class="p">-(</span><span class="n">tip</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> <span class="n">cameraXOffset</span> <span class="p">*</span> <span class="p">(</span><span class="m">2</span> <span class="p">*</span> <span class="n">image</span><span class="p">.</span><span class="n">Id</span> <span class="p">-</span> <span class="m">1</span><span class="p">))</span> <span class="p">/</span> <span class="n">tip</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">vSlope</span> <span class="p">=</span> <span class="n">tip</span><span class="p">.</span><span class="n">z</span> <span class="p">/</span> <span class="n">tip</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

    <span class="n">Vector</span> <span class="n">ray</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">hSlope</span> <span class="p">*</span> <span class="n">image</span><span class="p">.</span><span class="n">RayScaleX</span> <span class="p">+</span> <span class="n">image</span><span class="p">.</span><span class="n">RayOffsetX</span><span class="p">,</span>
         <span class="n">vSlope</span> <span class="p">*</span> <span class="n">image</span><span class="p">.</span><span class="n">RayScaleY</span> <span class="p">+</span> <span class="n">image</span><span class="p">.</span><span class="n">RayOffsetY</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>

    <span class="c1">//Pixel coordinates from [0..1] to [0..width/height]</span>
    <span class="n">Vector</span> <span class="n">pixel</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">targetWidth</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">targetHeight</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>

    <span class="c1">//Draw tip at pixel</span>
    <span class="n">targetBitmap</span><span class="p">.</span><span class="n">SetPixel</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">pixel</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pixel</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">Pink</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="calculate-the-direction-to-an-image-feature">
<h2>Calculate the Direction to an Image Feature<a class="headerlink" href="#calculate-the-direction-to-an-image-feature" title="Permalink to this headline">¶</a></h2>
<p>Get the direction to an image feature with the <a class="reference external" href="../api/Leap.Image.html#csharpclass_leap_1_1_image_1a7b31c05de1ce426d87dda5f0188fa675">Image.Rectify()</a> function. Image.Rectify() returns a vector containing the horizontal and vertical slopes (as defined from the camera point of view) given the pixel coordinates in the raw image data.</p>
<p>The following example illustrates how to get the slope data for each pixel in the image:</p>
<div class="highlight-csharp"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">horizontal</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">horizontal</span> <span class="p">&lt;</span> <span class="n">image</span><span class="p">.</span><span class="n">Width</span><span class="p">;</span> <span class="n">horizontal</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">vertical</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">vertical</span> <span class="p">&lt;</span> <span class="n">image</span><span class="p">.</span><span class="n">Height</span><span class="p">;</span> <span class="n">vertical</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Vector</span> <span class="n">slopes</span> <span class="p">=</span> <span class="n">image</span><span class="p">.</span><span class="n">Rectify</span><span class="p">(</span><span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">horizontal</span><span class="p">,</span> <span class="n">vertical</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
        <span class="c1">//Use the slope values ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you can identify the same feature in both images with sufficient accuracy, you can triangulate the 3D position using the set of slope values from the two cameras.</p>
</div>
<div class="section" id="head-mounted-display-mode">
<h2>Head-Mounted Display Mode<a class="headerlink" href="#head-mounted-display-mode" title="Permalink to this headline">¶</a></h2>
<p>The Leap Motion service/daemon software provides a mode that optimizes tracking when the Leap Motion hardware is attached to a head-mounted display. In this mode, the Leap Motion software expects to view hands from the top rather than the bottom. When ambiguity exists whether the palm of a hand is facing toward or away from the Leap Motion sensors, setting this mode makes it more likely that the software will initialize the hand model so that it is facing away from the sensors. Thus this mode is good for mounting the Leap Motion device on the face of a head-mounted display rig.</p>
<p>To turn on the mode in your application, enable the optimize HMD policy:</p>
<div class="code csharp highlight-python"><div class="highlight"><pre><span class="n">controller</span><span class="o">.</span><span class="n">SetPolicyFlags</span><span class="p">(</span><span class="n">Controller</span><span class="o">.</span><span class="n">PolicyFlag</span><span class="o">.</span><span class="n">POLICY_OPTIMIZE_HMD</span><span class="p">);</span>
</pre></div>
</div>
<p>The policy is always denied for hardware that cannot be mounted on an HMD, such as those embedded in laptops or keyboards.</p>
</div>
</div>


           <div id="disqus_thread"></div>
           <script type="text/javascript">
           var disqus_shortname = 'lmsdk'; // required: replace example with your forum shortname
           //var disqus_identifier = "???";
           (function() {
           var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
           dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
           (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
           })();
           </script>
      </div>
      <div id="sidebar" class="col-md-3">
        <div class="well-sidebar" data-offset-top="188">
          <ul>
            <li><a href="../index.html" title="Home">C# and Unity Docs (v2.1)</a></li>
          </ul><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Intro_Skeleton_API.html">Introducing the Skeletal Tracking Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="Leap_Overview.html">API Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practices/Leap_Practices.html">Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="Leap_Guides.html">Application Development</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Leap_Guides2.html">Using the Tracking API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Leap_Controllers.html">Connecting to the Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Tracking.html">Tracking Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Frames.html">Frames</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Hand.html">Hands</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Pointables.html">Fingers</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Gestures.html#id1">Gestures</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Touch_Emulation.html#id1">Touch Emulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Motions.html">Motions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Coordinate_Mapping.html">Coordinate Systems</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Camera Images</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#image-api-basics">Image API Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get-the-raw-images">Get the Raw Images</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get-the-calibration-map">Get the Calibration Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="#image-ray-correction">Image Ray Correction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#correction-using-image-warp-and-image-rectify">Correction using Image.Warp() and Image.Rectify()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#correction-using-shaders">Correction using Shaders</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encoding-distortion-data-in-an-24-bit-argb-texture">Encoding Distortion Data in an 24-bit ARGB Texture</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#draw-tracking-data-over-image">Draw Tracking Data over Image</a></li>
<li class="toctree-l3"><a class="reference internal" href="#calculate-the-direction-to-an-image-feature">Calculate the Direction to an Image Feature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#head-mounted-display-mode">Head-Mounted Display Mode</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/Leap_Classes.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../supplements/Leap_Supplements.html">Appendices</a></li>
</ul>


        </div>
      </div>
        
    </div>
  </div>
</div>
<!--

<div class="ribbon">
    <p>C# and Unity</p>
</div>


<footer>

  <div id="footer" class="container">

  <div class="container">
    <div class="copyright">
      <span>Copyright &copy; 2012 - 2014, Leap Motion, Inc.</span>
    </div>
  </div>
</footer>
  </body>
</html>